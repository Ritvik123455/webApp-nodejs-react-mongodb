STEP 1 : npm init (in the desired directory)
    -> Describes project name
    -> Lists dependencies
    -> Contains scripts (like start, build, test etc)
    -> Helps others and tools to understand how to run your code

During this setup, it asks for entry point. Entry point is the main file that node.js will
execute when our app starts.

STEP 2 : npm install --save express
    -> Save adds 'express' to the dependencies section of our package.json (which is created during npm init)
    -> It is remembered as something that our project needs
    -> express
        -> Web framework for node.js that helps us to build web servers and APIs

STEP 3 : npm --save-dev nodemon
    -> nodemon is a dev tool that auto restarts server when code changes are saved
    -> -dev makes sure this happens only during development

STEP 4 : code for our starter/entry point file. Doubts and clarifications related to code present inside server.js as comments

STEP 5 : npx nodemon --ext html,js,json
    -> npx
        -> tool that comes with node.js
        -> its job? run any node.js command line tool, even if not globally installed
        -> now we have already defined while npm init what the main file is, so when we simply run this command, it knows server.js is the main file and runs it
        -> if not using nodemon, we would do something like this node server.js
        -> essentially npx runs nodemon, which runs the main that we set in package.json during init
    -> nodemon 
        -> The tool that we are running using npx without having to globally install
        -> version details can be found in the package.json
    -> --ext ... 
        -> tells nodemon to check for changes in the files that have the following extensions

And that is how we can get a server to start running using node.

STATIC WEB SERVER
A static web server is a server that serves static files to the client — files that don’t change on the server side. These can be:

HTML files

CSS stylesheets

JavaScript files

Images (JPG, PNG, SVG)

Fonts

etc.

There’s no processing of data or logic involved — the files are just delivered as-is to your browser.

-> now we have added extra files to the project. we are required to run 'npx nodemon ./server.js'
    -> as compared to the command on STEP 5, this will only by default check for .js and json files
    -> if we include  the other extensions, then changes in any files of that sort will trigger changes

MONGO DB
    -> STEP 1 -CREATE CLUSTER
        -> Cluster - A group of servers that work together to store and handle requests
    -> STEP 2 - CREATE DATABASE
        -> Pretty straightforward, follow the steps on Mongodb website
        -> Add IP address 0.0.0.0 to be able to access from anywhere.
        -> save the connection string (mongodb+srv://ritzy224:6361865225@chartapp.0rkph82.mongodb.net/?retryWrites=true&w=majority&appName=chartApp)
    -> STEP 3 - npm install --save mongoose
        -> Mongoose (& mongodb)
            -> mongodb is the official node.js driver from Mongodb
            -> gives you low level access to MongoDB DATABASE
            -> more boilerplate code

            -> Mongoose is built on top of mongodb
            -> cleaner schema based way to work with MongoDB
            -> models and schemas like SQL 
            -> easy to validate, structure and manage relationships between data
CREATING THE FRONTEND (REACTJS)

    STEP 1 - INSTALLING dependencies
        -> npm install --save-dev webpack webpack-cli
        -> webpack is the main tool that bundles html, css, js all together for browser to efficiently load
        -> webpack-cli gives us the commandline tools to actually run and configure webpack
        -> --save-dev means we need them only in development, not in production

    STEP 2 - npm install npm --save react react-dom 
        -> installing react
    
    STEP 3 - npm install --save-dev @babel/core @babel/cli @babel/polyfill @babel/preset-react @babel/preset-env
        -> babel is a translator
        -> helps us run modern javascript in older browsers
    
    STEP 4 - npm install --save-dev babel-loader

    STEP 5 - npm install --save-dev clean-webpack-plugin html-webpack-plugin

    STEP 6 - npm install --save-dev css-loader style-loader

    STEP 7 - (Setting up react)
        -> create new file called webpack.config in project
        -> this file will have some information related to where our react app is
        -> what the name of the app is etc
    
    STEP 8 - create new folder 'src'
        -> inside it we create index.js file
        -> this index.js is mentioned as our react app location in the config file
    
    STEP 9 - create .babelrc file inside chartreact
        -> fill the property required there (in our case only 1)
    
    STEP 10 - after making code for index.js, we run npx webpack

    STEP 11 - npm install --save ejs

NOTES ON WHAT IS WEBPACK.CONFIG.JS
    -> This is a blueprint/ instruction manual telling webpack how to bundle  our javascript, css, Images
    -> mode
        -> Tells webpack that we are still building, make it easy to debug
        -> Gives better debugging tools, doesnt minify code
    
    -> entry
        -> This is the starting point of our app
        -> Webpack builds a dependency graph starting from this file
        -> myapp is the name of the entry point (we could chose anything)
        -> myapp will get replaced with the placeholder '[name]'

    -> module
        -> This is where we define how to handle different types of files
        -> webpack itself only understands js
        -> so these rules help teach webpack how to convert to js

    -> plugins
        -> JavaScript object with an apply method.
        -> Custom code that runs inside Webpack during the build to extend or modify its behavior.
    
    -> output 
        -> defines where our final bundled files will go 
        -> 
How to know what files go into webpack config?

No magic rule. learn as you encounter errors 




